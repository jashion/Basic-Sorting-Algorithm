# Basic-Sorting-Algorithm

关于十大基本排序算法的整理。

十大排序算法分别为：冒泡排序，选择排序，插入排序，希尔排序，堆排序，快速排序，归并排序，计数排序，桶排序和基数排序。

排序算法根据相同的值在排序之前和排序之后的前后位置是否不变来表示该排序算法是否稳定，如果不变则是稳定的，否则是不稳定的。

稳定：冒泡排序，插入排序，归并排序，计数排序，桶排序，基数排序

不稳定：选择排序，希尔排序，堆排序，快速排序

排序算法根据排序时所需数据是否一定要全部加载进内存来区分内外排，不需要则是外排，需要则是内排，注意，外排在数据少的时候也可以将需要排序的数据一次性全加载进内存，并不是外排就不可以处理数据少的情况，只是效率高与效率低的问题。

内排：冒泡排序，选择排序，插入排序，希尔排序，堆排序，快速排序

外排：归并排序，计数排序，桶排序，基数排序



#### 冒泡排序：两两相邻的数据比较，如果前面的数据比后面的数据大，则交换两个数据的位置，直到所有的数据有序。

```swift
//Swift
func bubbleSort(sortedList: inout [Int]) {
    var i: Int = 1
    var flag = true  //优化

    while i < sortedList.count && flag {
        flag = false
        for j in 0..<sortedList.count-i {
            if sortedList[j] > sortedList[j+1] {
                flag = true
                sortedList.swapAt(j, j+1)
            }
        }
        i++
    }
}
```

最好时间复杂度：最好的情况就是需要排序的数据完全有序，也就是只需要比较n-1次，移动0次，就可以得到一个完全有序的序列，所以时间复杂度为：O(n)。

最坏时间复杂度：需要排序的数据逆序，那么第一个数据需要比较n-1次，第二个数据需要比较n-2次，那么，总的比较时间为：n-1+n-2+n-3+...+1=(n^2-n)/2，也就是时间复杂度为：O(n^2)。

平均时间复杂度：(O(n)+O(n^2))/2=O(n^2)。

空间复杂度：因为排序是在原数组上进行交换和移动的，也就是不需要额外的辅助空间，严谨来说交换数据时需要一个临时的空间，所以空间复杂度为：O(1)。

稳定性：因为是相邻的元素两两比较，不存在跳跃比较，移动的情况，所以是稳定的排序。

排序类型：因为每次比较需要用到整个数组，换句话说需要把排序的数据一次性加载到内存里进行排序，所以是内排类型。



#### 选择排序：选择排序，每次都在无序的数据中选出最大的数据，并排在后面，直到所有的数据有序。

```swift
//Swift
func simpleSelectSort(sortedList: inout [Int]) {
    for j in 0..<sortedList.count-1 {
        for i in j+1..<sortedList.count {
            if sortedList[j] > sortedList[i] {
                sortedList.swapAt(j, i)
            }
        }
    }
}
```

时间复杂度：选择排序比较特殊，无论排序的数据是有序还是无序，时间复杂度都是一样的。因为就算整个数据有序，但是你不将所有的数据比较一次，是不可能知道这个数据就是最大或者最小的，虽然人眼是能看出来，但是机器看不出，所以，时间复杂度为：O(n^2)。

空间复杂度：和冒泡排序一样，最多使用一个数据空间，所以空间复杂度为：O(1)。

稳定性：因为需要在剩下的所有数据中寻找最大值，存在跳跃的情况，比如：5 4 5 3 2 => 4 3 5 2 5 很明显前面的5跑到后面来了，所以是不稳定的。

排序类型：同冒泡排序一样，需要一次性把排序的数据加载到内存，所以是内排。



#### 插入排序：插入排序是不断的将数据插入前面有序的序列，形成新的有序序列。

```swift
//Swift
func insertSort(sortedList: inout [Int]) {
    for j in 1..<sortedList.count {
        if sortedList[j] < sortedList[j-1] {
            let temp = sortedList[j]
            var i: Int = j-1
            while i >= 0 && sortedList[i] > temp {
                sortedList[i+1] = sortedList[i]
                i--
            }
            sortedList[i+1] = temp
        }
    }
}
```

最好时间复杂度：如果排序的数据完全有序，则只需要比较n-1次，不需要移动数据，则最好的时间复杂度为：O(n)。

最坏时间复杂度：如果排序的数据逆序，从第二数据开始，第一次在比较是否进入循环时，比较了一次，然后在循环比较移动时有比较了一次，也就是两次，总的时间复杂度为：2+3+4+...+n=(n+2)(n-1)/2，时间复杂度为：O(n^2)。

平均时间复杂度：O(n^2)。

稳定性：因为插入排序是一个一个数插入，也是相邻两个数据两两比较，不存在跳跃比较和移动的情况，所以是稳定的。

排序类型：同冒泡排序一样，需要一次性把排序的数据加载到内存，所以是内排。
